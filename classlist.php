<?php
/**
 * This file is auto-generated by PhpCocktail to help IDEs understand code where namespaces classes get dinamicly
 * 	shifted to root namespace.
 * It shall not be run at all, this the die.
 */

die('This file is not intended to be run.');

/**
 * This autoloader tries to load src in the root namespace by trying to aliase a class from various namespaces. It
 *	will default to load src from \Camarera namespace into root.
 *
 * @author t
 * @package Camarera\Autoloader
 * @license DWTFYWT
 * @version 1.01
 */
class AutoloaderNamespaceAliaser extends Camarera\AutoloaderNamespaceAliaser {};

/**
 * root namespace alias for IDEs 
 */
class FielValidatorMinlength extends Cocktail\FielValidatorMinlength {};

/**
 * special enum field for booleain (on/off) fields
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldBool extends Camarera\FieldBool {};

/**
 * integer field for models
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldInteger extends Camarera\FieldInteger {};

/**
 * string field for models
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldString extends Camarera\FieldString {};

/**
 * enum field for models, will store zero or one element of a set of possible values
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldEnum extends Camarera\FieldEnum {};

/**
 * set field for models, will store zero, one, or more elements of a set of possible values
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldSet extends Camarera\FieldSet {};

/**
 * timestamp field for models, will store datims in unix timestamp format
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldEmail extends Camarera\FieldEmail {};

/**
 * string field for models
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldPassword extends Camarera\FieldPassword {};

/**
 * timestamp field for models, will store datims in unix timestamp format
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 */
class FieldTimestamp extends Camarera\FieldTimestamp {};

/**
 * basic field for models, typed fields should have a definition class which extends this
 *
 * @author t
 * @package Camarera\Field
 * @license DWTFYWT
 * @version 1.1
 *
 * @property-read string $storeQuote see: $_storeQuote
 */
class Field extends Camarera\Field {};

/**
 * config class for sqlite3 store driver
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.01
 */
class StoreSqlSqlite3Config extends Camarera\StoreSqlSqlite3Config {};

/**
 * StoreConfig - base config for store driver configs. Each StoreXxx driver must have a StoreXxxConfig class which
 *	extends me, StoreConfig. I defined most of the commonly used parameters, however, not all store drivers may use them.
 * @see Camarera\Store on example usage
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.1
 * 
 * @property-read string $id internal ID of the store, in case you use more than one store you can refer them by this ID
 */
abstract class StoreConfig extends Camarera\StoreConfig {};

/**
 * StoreSql class contains logic and template methods for SQL-based drivers such as StoreMysql for MySql. The query
 * 	generated here shall be good enough for all drivers. You can still override those methods for your drivers, if you
 *	would need. Basicly you'll have to define few abstract methods which depend on driver level calls.
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.1
 */
abstract class StoreSql extends Camarera\StoreSql {};

/**
 * I define the base abstracts for StoreXxx drivers. Apart from very few implementation-dependent only things defined
 *	here should be accessed from the outside. CRUD methods for Models and Collections shall be called and wrapped by
 *	themselves only. Also, you can execute your own sql queries by execute() and query(). Note that Camarera currently
 *	does not include a query builder.
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.1
 *
 * @property-read StoreConfig $Config
 * @property-read string $id
 * @property-read string $lastQuery
 * @property-read array $lastErrors
 * @property-read int $lastAffectedRwos
 */
abstract class Store extends Camarera\Store {};

/**
 * I am a filter for a query, for internal usage. Indeed, I am just a representational object
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.1
 */
class StoreFilter extends Camarera\StoreFilter {};

/**
 * StoreSqlMysqli with new, recommended mysqli class usage
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.1
 */
class StoreSqlMysqli extends Camarera\StoreSqlMysqli {};

/**
 * Config class for mysqli store. See StoreConfig on available
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.1
 */
class StoreSqlMysqliConfig extends Camarera\StoreSqlMysqliConfig {};

/**
 * StoreSqlSqlite3 gives you simple file-based storage. Used by unit tests too.
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera\Store
 * @version 1.1
 */
class StoreSqlSqlite3 extends Camarera\StoreSqlSqlite3 {};

/**
 * I hold options for deleting a model
 * @author t
 * @package Camarera\Model
 * @version 1.01
 */
class ModelDeleteConfig extends Camarera\ModelDeleteConfig {};

/**
 * root namespace alias for IDEs 
 */
class ModelInfoManager extends Camarera\ModelInfoManager {};

/**
 * Model is the base class which your own classes should extend to form your models. This class has the base
 *	functionalities:
 *	* store and retrieve data, using a set of
 *  * field objects, which define properties of the model. Field objects are stored staticly and thus inflated only once
 *  * have a special ID field, (which can be an agregate of multiple fields)
 *  * load/save data from/to designated Store objects
 *  * can use model registry to apply previously fetched data
 *  * provide singleton access (if property definition in your class allows)
 *  * provide magic getters/setters/properties based on field definitions
 *  * define basic CRUD store operation wrappers
 *  * be a good base for collections
 *
 * note: if you want singleton functionality, add the \Camarera\TraitSingleton* trait to your class
 *
 * @author t
 * @package Camarera\Model
 * @version 1.01
 *
 * @property string $ID the unique ID of the object
 * @property-read boolean $isDirty
 * @property-read boolean $isRegistered
 * @property-read \ModelLoadConfg $LastLoadConfig
 */
abstract class Model extends Camarera\Model {};

/**
 * root namespace alias for IDEs 
 */
class FieldValidationException extends Camarera\FieldValidationException {};

/**
 * root namespace alias for IDEs 
 */
class ModelValidationException extends Camarera\ModelValidationException {};

/**
 * I hold options for saving a model
 * @author t
 * @package Camarera\Model
 * @version 1.01
 */
class ModelSaveConfig extends Camarera\ModelSaveConfig {};

/**
 * Model and Model data manager. It acts like a multiton pool, but can also store raw data for lazy instantiation.
 * 		- the multiton concept assures that you have shared named objects through your application, eg. if you load
 * 			user #1 at multiple code points independently, you still get the same object (without reloading)
 * 		- the data store just registers data for objects, and they are instanciated when they are asked for by get()
 * 		- I decided to make it static and not singleton, since I can't think of any case in which the manager would be
 * 			passed as a parameter
 * @author t
 * @package Camarera\Model
 * @version 1.01
 */
class ModelInstanceManager extends Camarera\ModelInstanceManager {};

/**
 * I hold options for Model get/load
 * @author t
 * @package Camarera\Model
 * @version 1.1
 *
 * @method $this setLoadFields(string|array|null $fields)
 * @method $this setAllowLoad(bool $allowLoad)
 * @method $this setLoadOrder($loadOrder)
 * @method $this setRegisteredInstance(bool $registeredInstance)
 * @method $this setData(array $data)
 */
class ModelLoadConfig extends Camarera\ModelLoadConfig {};

/**
 * CollectionBuilder it is yet a draft of a class which would take lot of responsibility from Collection, usually functions
 * 	you normally use once on a given collection
 * It extends Collection so it can manipulate protected object data (needed? if not, can be just a static class @todo)
 *
 * @package Camarera
 */
class CollectionBuilder extends Camarera\CollectionBuilder {};

/**
 *
 * @author t
 * @package Camarera\Collection
 * @version 1.01
 *
 * @property-read \CollectionGetConfig $GetConfig @see $_GetConfig
 * @property-read array $datas all object's datas
 * @property-read string $modelClassname @see $_modelClassname
 * @property-read array|string $modelIdFieldName modelClassname's idFieldName
 */
class Collection extends Camarera\Collection {};

/**
 * collection get/load behaviour config
 * @author t
 * @package Camarera\Collection
 * @version 1.01
 */
class CollectionLoadConfig extends Camarera\CollectionLoadConfig {};

/**
 * I will aggregate log content and output in __destruct(), in html format
 *
 * @author t
 * @package Camarera\Logger
 * @license DWTFYWT
 * @version 1.1
 */
class LoggerAppend extends Camarera\LoggerAppend {};

/**
 * Base config class, convenient to extend and thus form data containers. Configs do:
 *
 *  * ensure easy and clear inline-creation of configurables (by chained setXxx() methods)
 *
 *  * should be used in place of config arrays, for real configuration-like usage, or just as enclosing params to a method
 *
 *  * should be used in usage scope (in the object/method it is passed to), and not directly (eg. don't molest a Model's
 *  	Field->$default unless you have reason,)
 *
 * 	* have real properties defined in PHP, public or protected (tip: use @ property docs for easy autocomplete)
 *
 *  * by default, properties with names like $someThing are considered config properties (see $_fieldNameMask)
 *
 *  * protected properties are also exposed for getting, but not for setting (can be set through setProperty(), though)
 *  	protected properties can be accessed by $Object->propertyName instead of declared $_propertyName
 *
 *  * magic getXxx()/setXxx()/addXxx(), latter two can be chained for "fluid" objects
 *
 *  * you can define your getter/setter/magic methods over some properties and thus override default behaviour (eg.
 *		value checking or converting if necessary)
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera
 * @version 1.01
 *
 * <code>
 * class ManyParams extends \Config {
 *		public $param1;
 *		public $param2;
 *		...
 *		public $paramX;
 *
 *		// #return ManyParams (add proper phpdoc in live code to get nice autocomplete, cannot nest here in example)
 *		public static function serve($config=null) {
 *			return parent::serve($config);
 *		}
 * }
 *
 * // example on how to use as fluid object
 * $Foo->bar(
 *		ManyParams::serve()
 *			->setParam1('value1')
 *			->setParam2('value2')
 *			...
 *			->setParamXxx('value x')
 * );
 *
 * // this oldschool example is the same IDD
 * $ManyParams = ManyParams::serve();
 * $ManyParams->param1 = 'value1';
 * $ManyParams->param2 = 'value2';
 * ...
 * $ManyParams->paramX = 'value x';
 * $Foo->bar($ManyParams);
 * </code>
 *
 */
abstract class Config extends Camarera\Config {};

/**
 * root namespace alias for IDEs 
 */
class ConfigException extends Camarera\ConfigException {};

/**
 * Some utility methods
 * @author t
 * @package Camarera
 * @version 1.01
 */
class Util extends Camarera\Util {};

/**
 * Camarera is the main static class, grouping some main functionalities:
 *
 *	* logging: you can create and register loggers which are invoked by common Camarera::log() facility. Loggers and
 *		log messages both have a log level, and only loggers with equal or lower log levels will receive log messages.
 * @see Camarera::LOG_ALL
 *
 *	* autoloading: like logging, you can register your autologgers. Each have a namespace for which it is active and
 *		some data telling the autoloader where to look for files. Please read documentation on how Camarera handles
 *		src, autoloding, and how to extend core src.
 * @see Camarera::$_registeredAutoloaders
 *
 *	* stores: I take care of registering and returning store objects.
 * @see Camarera::$_stores
 *
 *  * conf: I take care of loading config files and retrieving config values from it
 * @see Camarera::$_confCache
 *
 * @author t
 * @license DWTFYWT
 * @package Camarera
 * @version 1.1
 */
class Camarera extends Camarera\Camarera {};

/**
 * thrown when unimplemented features are triggered
 */
class UnImplementedException extends Camarera\UnImplementedException {};

/**
 * thrown when a user defined class has definition errors (eg. doesn't contain required static fields for scoping)
 */
class ClassDefinitionException extends Camarera\ClassDefinitionException {};

/**
 * thrown when a __get fails to return a value
 */
class MagicGetException extends Camarera\MagicGetException {};

/**
 * thrown when a __set fails to set a value
 */
class MagicSetException extends Camarera\MagicSetException {};

/**
 * thrown when a __call fails to return a value
 */
class MagicCallException extends Camarera\MagicCallException {};

/**
 * thrown when a __callStatic fails to return a value
 */
class MagicCallStaticException extends Camarera\MagicCallStaticException {};

